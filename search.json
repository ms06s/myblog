[{"title":"computed 和 watch 的区别","date":"2020-06-14T16:00:00.000Z","url":"/2020/06/15/computed%20%E5%92%8C%20watch%20%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["vue"],"content":"computed 和 watch 的区别computedcomputed 是计算属性任何复杂的逻辑都应当使用计算属性计算属性中计算得到出来的属性可以直接使用，不需要加括号计算属性会根据依赖自动缓存，如果依赖不变，computed 的值也不会重新计算 watchwatch 是侦听器，用来侦听数据变化来响应如果侦听的数据发生变化，就会执行相应函数watch 有两个选项 immediate 表示是否在第一次渲染时执行相应函数immediate: true 表示执行 deep 表示是否要监听对象里面属性的变化deep: true 表示需要监听"},{"title":"浅析VUE数据响应式原理","date":"2020-06-09T16:00:00.000Z","url":"/2020/06/10/%E6%B5%85%E6%9E%90VUE%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","tags":["vue"],"content":"浅析VUE数据响应式原理当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项这些数据将会被 Vue 监听Vue 将会遍历此对象所有 property ，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter会被 Vue 实例代理 我们每次对 data 的读写都会被 Vue 监控每当 Vue 发现 data 更新时就会更新 UI 如果需要 Vue 监听一开始就没有传入 data 的属性，Vue 将无法监听这时需要使用 Vue.set 和 this.$set"},{"title":"VUE的两种构建版本的区别","date":"2020-05-20T16:00:00.000Z","url":"/2020/05/21/VUE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["vue"],"content":"VUE的两种构建版本的区别在使用vue时，我们可以引入两个不同版本的vue，分别时完整版（vue.js）和运行时版本（vue.runtime.js） 完整版和运行时版 UMD CommonJS ES Module (基于构建工具使用) ES Module (直接用于浏览器) 完整版 vue.js vue.common.js vue.esm.js vue.esm.browser.js 只包含运行时版 vue.runtime.js vue.runtime.common.js vue.runtime.esm.js - 完整版：同时包含编译器和运行时的版本 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是出去编译器的其他一切 UMD：UMD 版本可以通过 &lt;script&gt; 标签直接用在浏览器中。jsDelivr CDN 的  默认文件就是运行时 + 编译器的 UMD 版本（ vue,js ） CommonJS：用来配合老的打包工具，这些打包工具的默认文件是只包含运行时的 CommonJS 版本（ vue.runtime.common.js ） 区别 完整版 运行时版 评价 特点 有compiler 没有 compiler 完整版体积较大，其中仅compiler就占整个文件40%大小 视图 写在HTML中或者写在template选项中 写在 render 函数里，用 h 来创建标签 h 是尤雨溪写好传给 render 的 webpack 引入 需要配置 alias 默认使用此版本 尤雨溪所配置 @vue/cli 引入 需要额外配置 默认使用此版本 尤雨溪蒋豪群所配置 最佳实践：总是使用非完整版，然后配合 vue-loader 和 vue 文件思路： 保证用户体验，用户下载的 JS 文件体积更小，但支支持 h 函数 保证开发体验，开发者可直接在 vue 文件里写 HTML 标签，而不写 h 函数 脏活让 loader 做，vue-loader 把 vue 文件里的 HTML 转为 h 函数 "},{"title":"浅析MVC","date":"2020-05-16T16:00:00.000Z","url":"/2020/05/17/%E6%B5%85%E6%9E%90%20MVC/","tags":["mvc"],"content":"浅析 MVCMVC的三个对象MVC是三个字母的缩写，分别是Model（模型）、View（视图）和Controller（控制）这个模式认为不论程序简单或复杂，从结构上看，都可以分成这三类对象 Model: 数据模型 View: 视图 Controller: 控制器 大概过程就是通过m拿到数据，然后在c进行加工，最后通过v来渲染 表驱动编程Table-Driven Approach表驱动法是一种编程模式，从表里面查找信息而不是使用逻辑语句（if…else…switch），当是很简单的情况时，用逻辑语句很简单，但如果逻辑很复杂，再使用逻辑语句就很麻烦了。c对象中的根据events 表 autoEventsBing 来自动绑定事件就是一个例子还有： 主要有以下四种优点 逻辑与数据分离 逻辑修改成本巨大，数据修改成本极小 逻辑修改风险巨大，数据修改风险极小 数据来源灵活，数据改变灵活 eventsBusEventBus是一种设计模式或框架，主要用于组件/对象间通信的优化简化EventBus 作为m，v，c 的父类，实现了mvc之间的通信 模块化mvc将底层的一团乱麻分为各不依赖，互不干扰的模块方便模块间组合，分离，单个模块功能调试升级降低各个功能模块间的耦合度 MVC，MVP和MVVM之间的区别MVCMVC模式的意思是，软件可以分成三个部分 视图（view）：用户界面 控制器（Controller）：业务逻辑 模型（Model）：数据保存 通信模式如下 View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View ，用户得到反馈 所用通信都是单向的 MVPMVP 模式将 Controller 改名为 Presenter ，同时改变了通信方向 各部分之间的通信，都是双向的 View 与 Model 不发生联系，都通过 Presenter 传递 View 非常薄，不部署任何业务逻辑，成为”被动视图” （Passive View），即没有任何主动性，而 Presenter 非常厚，所有逻辑都部署在那里 MVVMMVVM 模式将 Presenter 改名为 ViewModel ，基本与MVP模式完全一致唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel ，反之亦然。Angular 在采用这种模式"},{"title":"DOM事件机制","date":"2019-08-19T16:00:00.000Z","url":"/2019/08/20/DOM%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","tags":["dom"],"content":"DOM事件机制研究DOM事件机制，让我从点击事件开始说起 点击事件 即.grandFather&gt;.father&gt;.son给这三个div分别添加监听 fnGrand / fnFather / fnSon 问：点击了谁点击文字，算不算点击 son ？点击文字，算不算点击 father ？点击文字，算不算点击 grandFather ？答：都算 问：调用顺序点击文字，最先调用 fnGrand / fnFather / fnSon 中哪一个函数？答：都行ie5认为先调用 fnSon，网景认为先调用 fnGrand这时，W3C发布了标准 2002年，W3C发布标准规定浏览器应该同时支持两种调用顺序首先 按 爷爷=&gt;爸爸=&gt;儿子 顺序看有没有函数监听然后 按 儿子=&gt;爸爸=&gt;爷爷 顺序看有没有函数监听有监听函数就调用，并提供事件信息，没有就跳过 事件捕获从外向内 **找监听函数，叫 **事件捕获从内向外 **找监听函数，叫 事件冒泡****那岂不是每次点击都要先捕获一次然后再冒泡一次吗？答：开发者自己选择监听函数放在捕获阶段还是冒泡阶段 示意图 事件监听事件绑定api 如果bool不传或为falsy就让fn走冒泡，即当浏览器在冒泡阶段发现当前元素有监听函数，就会调用fn，并提供事件信息 如果bool为true就让fn走捕获，即当浏览器在捕获阶段发现当前元素有监听函数，就会调用fn，并提供事件信息 图解 关于事件函数中的e 简单来说就是指向了当前发生的事件（click、mouseover等等），保存了当前事件的信息。如鼠标点击事件，有鼠标的坐标信息e可加可不加，如果后面需要获取操作信息 就要加e 如果不需要，只是完成一个事件，就可以不加 target 与 currentTarget区别e.target - 用户操作的元素e.currentTarget - 程序员监听的元素监听函数中的 this 是 e.currentTarget ，容易分不清 举例div&gt;span{文字}，用户点击文字e.target 就是 spane.currentTarget 就是 div 一个特例背景只有一个div被监听 (不考虑父子同时被监听)fn分别在捕获阶段和冒泡阶段监听 click 事件用户点击的元素就是开发者监听的 代码 问，f1先执行还是f2先执行？如果把两行调换位置后，哪个先执行？答：谁先监听谁先执行 取消冒泡捕获不可取消，但冒泡可以e.stopPropagation() 可中断冒泡，浏览器不再向上走一般用于封装某些独立组件 有些事件不可取消冒泡MDN搜索event，每个事件都可以看到 Bubbles 和 CancelableBubbles 意为该事件是否冒泡Cancelable 意为开发者是否可以取消冒泡 事件委托子元素委托祖先元素监听这个子元素本该监听的事件 场景一如何给100个按钮添加点击事件答：监听这100个事件的祖先，等冒泡的时候判断 e.target 是不是这100个按钮中的一个 场景二如何监听目前不存在的元素的点击事件答：监听祖先，等点击的时候看看是不是想要监听的元素即可 优点省内存可以监听动态元素 封装事件委托要求on(‘click’, ‘#div1’, ‘button’, fn)当用户点击#testDiv 里的 li 元素时，调用 fn 函数要求用到事件委托 上面代码有问题如果此时结构 执行 on(‘click’, ‘#div1’, ‘button’, fn)这时点击按钮，e.target 为 span 元素t.matches(selector)为 false 递归实现 JS 支持事件吗支持，也不支持DOM事件不属于JS的功能，属于浏览器提供的DOM的功能JS只是调用了DOM提供的addEventListener而已"},{"title":"JS函数执行时机","date":"2019-07-25T16:00:00.000Z","url":"/2019/07/26/JS%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/","tags":["js"],"content":"JS函数执行时机我们从7个小例子来探讨下js函数的调用时机 例1代码 请问打印出多少？ 答无，因为没有调用函数=&gt;执行需要先调用函数 例2代码 请问打印出多少？ 答1，显而易见 例3代码 请问打印出多少？ 答2在函数fn调用时，变量a已经变为了2 例4代码 f 请问打印出多少？ 答1函数调用时变量a值为1，调用结束后值重新赋值为2 例5代码 请问打印出多少？ 答2上述代码setTimeout函数意为尽快执行，也就是等一小段时间后执行这时会先执行完其他代码（此时变量a的值为2），然后再执行setTimeout函数举一个大家都遇到过的例子比如你正在打dota，你妈喊你吃饭，这是你肯定是先打完dota再去吃饭这个代码也是，先执行完其他代码后再去执行setTimeout函数 例6代码 请问打印出多少 答6个6，而不是0、1、2、3、4、5和例6同理，先执行完for循环和其他代码，此时变量i 的值为6，然后再执行setTimeout 函数，打印变量i 的值 例7代码 请问打印出多少 答0、1、2、3、4、5当let与for配合使用时，每次循环会多创建一个变量，然后将此时 i 的值赋值给这个变量怪"},{"title":"JS对象","date":"2019-07-16T16:00:00.000Z","url":"/2019/07/17/JS%E5%AF%B9%E8%B1%A1/","tags":["js"],"content":"JS对象对象定义 无序的数据集合 键值对的集合写法 细节 键名是字符串，不是标识符，可以包含任意字符 引号可以省略，省略之后就只能写标识符 就算引号省略了，键名也还是字符串⭐⭐⭐ 奇怪的属性名所有属性名会变成字符串 细节 变量做属性名如何用变量做属性名之前都是用常量做属性名 对比不加[] 的属性名会自动变成字符串加了[] 则会当做变量求值值如果不是字符串，则会自动变成字符串 对象的隐藏属性隐藏属性JS中每一个对象都有一个隐藏属性这个隐藏属性储存着其共有属性组成的对象的地址这个共有属性组成的对象叫做原型也就是说，隐藏属性储存着原型的地址 代码示例 增删改查删除属性delete obj.xxx 或 delete obj[‘xxx’]即可删除obj 的xxx 属性请区分 “属性值为undefined” 和 “不含属性名” 不含属性名‘xxx’ in obj === false //判断这个对象是否有 ‘xxx’ 这个属性 含有属性名，但是值为undefined‘xxx’ in obj &amp;&amp; obj.xxx === undefined 注意obj.xxx === undefined不能判定’xxx’ 是否为obj 的属性，只能判断obj 属性值’xxx’ 为undefined没有就是没有，undefined就是undefined绝不含糊 ‘name’ in obj 与 obj.hasOwnProperty(‘name’)的区别‘name’ in obj 如果对象中没有 ‘name’ 属性，就会去隐藏属性中找，找到了返回true 失败返回falseobj.hasOwnProperty(‘name’) 是在对象自身属性中找，找到了返回true 失败返回false 查看所有属性 (读属性)查看自身所有属性Object.keys(obj) 查看自身+共有属性console.dir(obj) 判断一个属性是自身的还是共有的obj.hasOwnProperty(‘toString’) 原型每个对象都有原型 原型里存着对象的共有属性 比如obj的原型就是一个对象 obj.__proto__存着这个对象的地址 这个对象里有toString/constructor/valueOf等属性 对象的原型也是对象 所以对象的原型也有原型 obj = {} 的原型即为所有对象的原型 这个原型包含所有对象的共有属性，是对象的根 这个原型也有原型，是null 查看属性两种方法查看属性中括号语法：obj[‘key’]点语法：obj.key //为字符串’key’坑新人语法：obj[key] //变量key值一般不为 ‘key’ 请优先使用中括号语法点语法会误导，让人以为key不是字符串 修改或增加属性 (写属性)直接赋值 批量赋值Object,assign(obj, {age: 18, gender: ‘man’}) 修改或增加共有属性(没有的话就直接增加了)无法通过自身修改或增加共有属性obj.toString = ‘xxx’ 只会在改obj自身属性obj2.toString 还是在原型上 我偏要修改或增加原型上的属性obj.proto.toString = ‘xxx’不推荐使用__proto__，所有的__proto__代码都是强烈不推荐写的 obj.prototype.toString = ‘xxx’一般来说，不要修改原型，会引起很多问题 修改隐藏属性不推荐使用proto 推荐使用Object.create"},{"title":"JS基础语法","date":"2019-07-07T16:00:00.000Z","url":"/2019/07/08/JS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","tags":["js"],"content":"JS基础语法表达式与语句表达式1+2表达式的值为3add(1, 2)表达式的值为函数的返回值console.log表达式的值为函数本身console.log(3)表达式的值为undefined 语句var a = 1 是一个语句 区别表达式一般都有值，语句可能有也可能没有语句一般会改变环境(声明、赋值)上面两句话并不是绝对的 大小写敏感var a 和 var A 是不同的object 和 Object 是不同的function 和 Function 是不同的具体含义后面再说 空格大部分空格没有实际意义加回车大部分时候也不影响只有一个地方不能加回车，那就是return后面 标识符规则第一个字符，可以是Unicode字母或$或或中文(规范，”“下划线最多两个)后面的字符，除了上面所说，还可以有数字 注释注释分为好的注释和不好的注释 不好的注释把代码翻译成中文过时的注释发泄不满的注释 好的注释踩坑注解为什么代码会写的这么奇怪，遇到什么bug 区块 block把代码包在一起 常常与if/for/while 合用 if 语句语法 {} 在语句只有一句的时候可以省略，不建议 程序员戒律使用最没有歧义的写法！ switch 语句语法 break大部分的时候，省略break会引起很多麻烦少部分的时候，可以利用breakswitch不推荐 问号冒号表达式(三元表达式)表达式1? 表达式2: 表达式3一般在if 判断语句只有一个简单的判断时可以用三元表达式替代 &amp;&amp;短路逻辑A &amp;&amp; B || 短路逻辑A || B while语法 判断表达式的真假当表达式为真，执行语句，执行完再判断表达式的真假当表达式为假，退出循环，执行后面语句 for 循环语法 先执行语句1然后判断表达式2如果为真，执行循环体，然后执行语句3如果为假，直接退出循环，执行后面语句 break 和 continuebreak 退出当前循环continue 退出当前一次循环"},{"title":"JS数据类型（简单数据类型）","date":"2019-07-02T16:00:00.000Z","url":"/2019/07/03/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)/","tags":["js"],"content":"JS数据类型(简单数据类型)七种数据类型 数字 number 字符串 string 布尔 bool 符号 symbol 空 undefined 空 null 对象 object 总结：四基两空一对象 数字JaveScript中数字都是以64位浮点数形式存储 特殊值正0和负0都等于0一个正数除以0或者正0得到Infinity一个负数除以负0得到-Infinity 无穷大Infinity、+Infinity、-Infinity 无法表示的数字NaN (Not a Number)但它是一个数字 字符串 string每个字符两个字节 写法单引号&#39;你好&#39; 双引号&quot;你好&quot; 反引号 反引号可以定义多行字符串，或者再字符串中嵌入变量 注意引号不属于字符串的一部分，如果要在单引号里面包含单引号怎么办答案是转义 转义错误写法&#39;it&#39;s ok&#39;JS引擎会认为 &#39;it&#39; 就结束了，后面无法解析 正确写法`` 常用转义字符&#39; 表示 ‘&#39;‘ 表示 ‘’\\n 表示换行\\r 表示回车\\t 表示tab制表符\\ 表示 \\ 字符串的属性等等！对象才有属性，为什么字符串也有属性先挖个坑，写完对象再来解答 字符串的长度string.length‘123’.length //3‘\\n\\r\\t’.length // 3转义字符算一个长度‘’.length //0‘ ‘.length // 1 通过下标读取字符string[index]let s = ‘hello’ s[0] // ‘h’ 注意index从0开始s[0]是第一个字符 注意index到lengthlet s = ‘hello’s[5] // undefined，不报错？？s[4] // ‘o’ 布尔 boolean真或假 只有两个值true 和 false，注意大小写 五个falsy值 ⭐⭐⭐falsy 就相当于false 但又不是false 的值 undefined null 0 NaN ‘’ (注：空字符串) 只有这5个值和布尔值false 是false，其他值均为true undefined 和 null 两种空类型空空如也 为什么有两个空js原创垃圾 区别没有本质区别 如果一个变量声明了，但没有赋值，那么默认值就是undefined，而不是null（null有种人为的意思） 如果一个函数，没有写return，那么默认return undefined ，而不是null 习惯上把非对象的空值写成undefined，把对象的空值写为null symbol不常用 变量声明三种声明方式 区别var 是过时的，不好用的方式let 是新的，更合理的方式const 是声明时必须赋值，且不能再改的方式 var 声明0202了，基本不用，挖个坑，回来再讲 let 声明规则遵循块作用域，即使用范围不能超出{}不能重复声明可以赋值，也可以不赋值必须先声明再使用全局声明let变量，不会变成window的属性for循环配合let有奇效 const声明跟let几乎一摸一样声明时要赋值，且不能改 变量声明指定值let a = 1 //a为1 同时也指定了类型let a = 1 //number类型 但是值和类型都可以随意变化a = 2a = ‘字符串’ name 和 ‘name’ 的区别name 是变量值可变，可能是’name’，也可能是’hello’ ‘name’ 是字符串常量常量就是不变量‘name’ 只能是’name’ ，不能是其他值 类型转换"},{"title":"CSS动画与浏览器渲染原理","date":"2019-06-21T16:00:00.000Z","url":"/2019/06/22/CSS%E5%8A%A8%E7%94%BB%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/","tags":["css"],"content":"CSS动画与浏览器渲染原理最简单的动画例子将div从左往右移动利用定时器每过一段时间增加left数值使div看起来向左移动  可以打开开发者工具看下这个动画的性能打开开发者工具，按esc，选择Rendering，然后勾选第一个选项，这时浏览器画面每变绿一次就说明重新绘制了一次 这是再点开上图例子，利用开发者工具就可以看出，浏览器在一直不停重新绘制图形 试试transform(变形) 原理transform: translateX(300px);向X轴平移300pxtransition会自动补充中间缺失的帧 这时我们可以打开开发者工具看下transform的渲染性能可以看到只有开始和结束进行了绘制现在我们来深入了解下浏览器渲染原理吧 浏览器渲染原理可以看下google团队写的文章渲染树构建、布局及绘制渲染性能 浏览器渲染过程 根据HTML构建HTML树(DOM) 根据CSS构建CSS树(CSSOM) 将两棵树合并成一颗渲染树(render tree) Layout布局(文档流、盒模型、计算大小和位置) Paint绘制(把边框颜色、文字颜色、阴影等画出来) Compose合成(根据层叠关系展示画面) 三棵树 三种更新方式第一种，全部流程走一遍例: div.remove() 会触发当前div消失，其他元素relayout第二种，跳过layout例: 改变背景颜色，不改变当前布局，直接repaint+composite第三种，跳过layout和paint例: 改变transform，只需composite 如何查看每个属性触发什么流程 transform和transition一些经验transform四个常用功能位移 translate缩放 scale旋转 rotate倾斜 skew 一般都需要配合transition过度inline元素不支持transform，需要先变成block translateleft: 50%; top: 50%;transform: translate(-50%. -50%);绝对定位元素居中的完美答案 scale用的较少，容易出现模糊 rotate一般用于360度旋转制作loading transition 过渡作用：补充中间帧 并不是所有属性都能过度display: none =&gt;block没法过渡一般改成visibility: hidden=&gt;visibledisplay和visibility的区别凡是可以有规律渐变的一般都能过渡如background的颜色 000=&gt;fff opacity 0.1=&gt;0.9 过度必须要有起始 animation缩写语法animation: 时长|过渡方式|延迟|次数|方向|填充模式|是否暂停|动画名; 例: 跳动的心"},{"title":"CSS定位","date":"2019-06-17T16:00:00.000Z","url":"/2019/06/18/CSS%E5%AE%9A%E4%BD%8D/","tags":["css"],"content":"CSS定位盒模型讲到定位时，就不得不再复习一下盒模型问题来了，background的颜色到底是被border遮住还是在border之内呢？  由此我们可以看出，背景色是被边框遮住的文本内容在最上面，边框在中间，背景在最下面那其他元素呢？块级元素，浮动元素，他们又在哪一层？ 其中蓝色为浮动元素，绿色为块级元素由此可以得出一个div的分层 "},{"title":"关于HTML语义化","date":"2019-06-11T16:00:00.000Z","url":"/2019/06/12/%E5%85%B3%E4%BA%8EHTML%E8%AF%AD%E4%B9%89%E5%8C%96/","tags":["html"],"content":"语义标签是什么, 使用它有什么好处为什么要用语义标签？ 语义类标签对开发者更为友好，使用语义类标签增强了可读性，即便是在没有CSS的时候，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护。 除了对人类友好之外，语义类标签也十分适宜机器阅读。它的文字表现力丰富，更适合搜索引擎检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。 错误地使用语义标签会给机器阅读造成混淆、增加嵌套，给CSS编写加重负担。 但是在“软件界面”的场景中，实际上几乎是没有语义的。所以在任何“软件界面”的场景中，直接使用div和span。 对于语义标签，用对比不用好， 不用比用错好 ​ 自然语言表达能力的补充表达一定结构在日语中，有一个语法现象叫做：ルビ，它的读音是ruby（著名的ruby语言就是据此命名的），它中文的意思大约类似于注音或者意思的注解，它的形式可以看下图： ![Unlimiter Rulebook](img/Unlimiter Rulebook.png) 像这样字幕上写的“多数例外规则”， 动画的台词用了英文发音“Unlimiter Rulebook”就形成了一个使用ruby的场景。 我们日常聊天纯文字没有办法好好表达，HTML作为一种“超文本”语言，支持这些文字表达就是必要的了。 HTML5中就引入了ruby标签，由ruby、rt、rp三个标签来实现。 ​ 消除歧义还有一种情况是，HTML的有些标签实际上就是必要的，甚至必要的程度可以达到：如果没有这个标签，文字会产生歧义的程度。 em标签 我们看看这句话，看上去它很清楚，但是实际上，这句话放到不同上下文中，可能表达完全不同的意思。 再比如： 试着读一读，这两段里面的“今天我吃了一个苹果”，你是不是发现读音不自觉地发生了变化？ 实际上，不仅仅是读音，这里的意思也发生了变化。前一段中，表示我今天吃的是苹果，而不是别的什么东西，后一段中，则表示我今天只吃了一个苹果，没有多吃。 当没有上下文时，如何消除歧义呢？这就要用到我们的em标签了。em表示重音： 通过em标签，我们可以消除这样的歧义。 一些文章常常会拿em和strong做对比，实际上，我们只要理解了em的真正意思，它和strong可谓天差地别，并没有任何混淆的可能。 ​ 作为标题摘要的语义类标签h1-h6是最基本的标题，它们表示了文章中不同层级的标题。有些时候，我们会有副标题，为了避免副标题产生额外的一个层级，我们使用hgroup标签。 我们来看下有/无hgroup的对比： 此段生成以下标题结构： JavaScript对象 我们需要模拟类吗？ … 这一段生成以下标题结构： JavaScript对象——我们需要模拟类吗？ … 我们通过两个效果的对比就可以知道，在hgroup中的h1-h6被视为同一标题的不同组成部分。 从HTML 5开始，我们有了section标签，这个标签可不仅仅是一个“有语义的div”，它会改变h1-h6的语义。section的嵌套会使得其中的h1-h6下降一级，因此，在HTML5以后，我们只需要section和h1就足以形成文档的树形结构： 这段代码同样会形成前面例子的标题结构： HTML语义 弱语义 结构性元素 …… ​ 作为整体结构的语义类标签我们想介绍的最后一个场景是，随着越来越多的浏览器推出“阅读模式”，以及各种非浏览器终端的出现，语义化的HTML适合机器阅读的特性变得越来越重要。 应用了语义化结构的页面，可以明确地提示出页面信息的主次关系，它能让浏览器很好地支持“阅读视图功能”，还可以让搜索引擎的命中率提升，同时，它也对视障用户的读屏软件更友好。 我们正确使用整体结构类的语义标签，可以让页面对机器更友好。比如，这里一个典型的body类似这样： 在body下面，有一个header，header里面是一个nav，跟header同级的有一个aside，aside里面也有一个nav。接下来是文章的整体，也就是一个一个的section。section里面可能还有嵌套，但是我们就不管了，最后是一个footer，这个footer里面可能有address这样的内容。 除此之外，还有article，article是一种特别的结构，它表示具有一定独立性质的文章。所以，article和body具有相似的结构，同时，一个HTML页面中，可能有多个article存在。 一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用article来组织。 body里面有自己的header和footer，然后里面是竖篇的article，每一个article里面都有自己的header、section、footer。这是一个典型的多文章结构。 在这个结构里，我们看到了一些新标签，我也来逐个介绍一下。 header，如其名，通常出现在前部，表示导航或者介绍性的内容。 footer，通常出现在尾部，包含一些作者信息、相关链接、版权信息等。 header和footer一般都是放在article或者body的直接子元素，但是标准中并没有明确规定，footer也可以和aside，nav，section相关联（header不存在关联问题）。 aside表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容。 aside很容易被理解为侧边栏，实际上二者是包含关系，侧边栏是aside，aside不一定是侧边栏。 aside和header中都可能出现导航（nav标签），二者的区别是，header中的导航多数是到文章自己的目录，而aside中的导航多数是到关联页面或者是整站地图。 最后footer中包含address，这是个非常容易被误用的标签。address并非像date一样，表示一个给机器阅读的地址，而是表示“文章（作者）的联系方式”，address明确地只关联到article和body。 ​ 总结本篇中我们介绍了一些基本原则和HTML文档的整体结构，从整体上了解了HTML语义。 至此，我们可以回答是否要语义化的问题：我们应该分开一些场景来看语义，把它用在合适的场景下，可以获得额外的效果。本篇文中，我们至少涉及了三个明确的场景： 自然语言表达能力的补充； 文章标题摘要； 适合机器阅读的整体结构。 "},{"title":"HTML常用标签","date":"2019-06-03T16:00:00.000Z","url":"/2019/06/04/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/","tags":["html"],"content":"HTML常用标签HTML 常用标签Iframe标签HTML内联框架元素表示嵌套的浏览上下文, 有效地将另一个HTML页面嵌入到当前页面中。在HTML 4.01中，文档可能包含头部和正文，或头部和框架集，但不能包含正文和框架集。但是，可以在正常的文档主体中使用。每个浏览上下文都有自己的会话历史记录和活动文档。包含嵌入内容的浏览上下文称为父浏览上下文。顶级浏览上下文（没有父级）通常是浏览器窗口。 iframe目前用的比较少, 一些遗留项目会使用iframe 属性 frameborder, iframe默认会有一个很丑的边框, 所有在写iframe的时候, 加上属性frameborder=&quot;0&quot;可以消除边框. css写样式的时候, width可以是使用百分比或者像素, height只能是像素. name , 通常与a标签结合使用. src, 一般都是网址src=&quot;;, 也可以是相对路径src=&quot;./index.html&quot;, 嵌套空白页src=&quot;about:blank&quot;或者是src=&quot;#&quot; sandbox, 如果指定了空字符串，该属性对呈现在iframe框架中的内容启用一些额外的限制条件。属性值可以是用空格分隔的一系列指定的字符串, 比如:sandbox=&quot;allow-forms&quot; allow-forms:允许嵌入的浏览上下文可以提交表单。如果该关键字未使用，该操作将不可用。 allow-modals: 允许内嵌浏览环境打开模态窗口。 allow-orientation-lock: 允许内嵌浏览环境禁用屏幕朝向锁定 srcdoc, 该属性值可以是HTML代码，这些代码会被渲染到iframe中，如果同时指定了src属性，srcdoc会覆盖src所指向的页面。该属性最好能与sandbox和seamless属性一起使用。 seamless, 该布尔属性指示浏览器将iframe渲染成容器页面文档的一部分。例如，通过打被包含的文档的链接，在iframe页面的样式被渲染之前，父页面的CSS样式就可以应用在iframe中（除非被其他设置阻止）。 a标签HTML 元素 (或锚元素) 可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他URL的超链接。 属性 download: 此属性指示浏览器下载URL或者文件而不是导航到它，因此将提示用户将其保存为本地文件。此属性仅使用于**同源URL**, 如果不是同源(同域), 将会导航到该URL, 例如: &lt;a href=&quot;; download=&quot;ss&quot;&gt;下载&lt;/a&gt; 会下载同源的一个ss.html &lt;a href=&quot;; download=&quot;ss&quot;&gt;下载&lt;/a&gt;, download无效, 导航到qq.com target: 该属性指定在何处显示链接的资源。 取值为标签（tab），窗口（window），或框架（iframe）等浏览上下文的名称或其他关键词。 target=&quot;_self&quot;: 当前页面加载, 如果没有指定此属性的话, 该值是默认值. target=&quot;_blank&quot;: 新窗口打开 target=&quot;_parent&quot;: 会加载到当前页面的父页面, 如果没有父页面,则等同于_self targe=&quot;_top&quot;: 会加载到最上层页面, 祖先级页面, 当index1.thml包含index2.html, index2.html包含index3.html, 则index3.html中的跳转则会加载到index1.html上 href: 包含超链接指向的URL或URL片段。 &lt;a href=&quot;qq.com&quot;&gt;QQ&lt;/a&gt;: 点击QQ不会跳转到qq.com, 会把qq.com当成文件, 不是以.com为后缀就是网址,也可以是文件 &lt;a href=&quot;//qq.com&quot;&gt;QQ&lt;/a&gt;, 不写协议的时候, 无协议绝对地址, 默认是当前页面协议, 是file协议, 就跳转, 是HTTP协议, 就跳转. &lt;a href=&quot;xxx.html&quot;&gt;QQ&lt;/a&gt;, 相对路径, 路径只会以目录为参考, 如果在index.html中跳转, 并不会以index.html为前缀index.html/xxx.html, 会显示xxx.html &lt;a href=&quot;#1&quot;&gt;QQ&lt;/a&gt;, 写锚点, 会自动加到后面, 不会发起请求, index.html#1, 虽然不会发起请求,但是页面会有变化. &lt;a href=&quot;?name=xxx&quot;&gt;QQ&lt;/a&gt;, 写参数, 会自动加到后面, 并发起GET请求, index.html?name=xxx &lt;a href=&quot;javascript: alert(1)&quot;&gt;QQ&lt;/a&gt;, 伪协议, 会执行js代码. &lt;a href=&quot;javascript:;&quot;&gt;QQ&lt;/a&gt;, 伪协议, 使其标签点击不跳转 &lt;a href=&quot;&quot;&gt;QQ&lt;/a&gt;, 什么也不写, 页面会刷新, 跳转到了自己. name: 和iframe配合使用 form标签HTML 元素 表示了文档中的一个区域，这个区域包含有交互控制元件，用来向web服务器提交信息。 a标签和form标签都是跳转, 区别就是a标签发起的是GET请求, form标签发起的是POST请求. 属性 action: 提交(POST)数据所到的地方.action=&quot;users&quot;, 就是提交到users, 一个处理这个form信息的程序所在的URL. autocomplete: 用于指示 input 元素是否能够拥有一个默认值，这个默认值是由浏览器自动补全的。这个设定可以被属于这个form的子元素的 autocomplete 属性重载（覆盖） off: 在每一个用到的输入域里，用户必须显式的输入一个值，或者document 以它自己的方式提供自动补全；浏览器不会自动补全输入。 on: 浏览器能够根据用户之前在form里输入的值自动补全。 enctype: 当 method 属性值为 post 时, enctype 是提交form给服务器的内容的 MIME 类型 application/x-www-form-urlencoded: 如果属性未指定时的默认值 multipart/form-data: 这个值用于一个 type 属性设置为 “file” 的 `` 元素。 text/plain (HTML5) method: 浏览器使用这种 HTTP 方式来提交 form, GET一般不用写, 如果是GET, 提交的数据会被作为查询参数, 并不会放到第四部分作为formdata, POST会把提交的数据放到formdata里, 如果要给POST加查询参数, 可以通过给URL加查询参数?user=zzz post: 指的是 HTTP POST 方法 ; 表单数据会包含在表单体内然后发送给服务器. get: 指的是 HTTP GET 方法; 表单数据会附加在 action 属性的URL中，并以 ‘?’ 作为分隔符, 然后这样得到的 URI 再发送给服务器. 当这样做（数据暴露在URL里面）没什么副作用，或者表单仅包含ASCII字符时，再使用这种方法吧。 target: 和a标签相同 name : HTML5中，一个文档中的多个form当中，name必须唯一而不仅仅是一个空字符串. 也可以与iframe标签配合使用. 如果form标签没有提交按钮, 则无法提交, html里只有form标签能提交数据 input标签HTML input 元素用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。使用input标签提交数据, 必须有name属性. 属性 type : 要呈现的控件类型 type=&quot;button&quot;: 普通按钮 type=&quot;checkbox&quot;: 复选框。必须使用 value 属性定义此控件被提交时的值 color：HTML5 用于指定颜色的控件。 date：HTML5 用于输入日期的控件（年，月，日，不包括时间）。 datetime：HTML5 基于 UTC 时区的日期时间输入控件（时，分，秒及几分之一秒）。 datetime-local：HTML5 用于输入日期时间控件，不包含时区。 email：HTML5 用于编辑 e-mail 的字段。 合适的时候可以使用 :valid 和 :invalid CSS 伪类。 file：此控件可以让用户选择文件。使用 accept 属性可以定义控件可以选择的文件类型。 hidden：不显示在页面上的控件，但它的值会被提交到服务器。 image：图片提交按钮。必须使用 src 属性定义图片的来源及使用 alt 定义替代文本。还可以使用 height 和 width 属性以像素为单位定义图片的大小。 month：HTML5 用于输入年月的控件，不带时区。 number: HTML5 用于输入浮点数的控件。 password：一个值被遮盖的单行文本字段。使用 maxlength 指定可以输入的值的最大长度 。 radio：单选按钮。必须使用 value 属性定义此控件被提交时的值。使用checked 必须指示控件是否缺省被选择。在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值； 一个单选按钮组中是，同一时间只有一个单选按钮可以被选择。 reset：用于将表单所内容设置为缺省值的按钮。 search：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。 submit：用于提交表单的按钮。 tel：HTML5 用于输入电话号码的控件；换行会被自动从输入的值中移除A，但不会执行其他语法。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 :valid 和 :invalid CSS 伪类。 text：单行字段；换行会将自动从输入的值中移除。 time：HTML5 用于输入不含时区的时间控件。 url：HTML5 用于编辑URL的字段。 The user may enter a blank or invalid address. 换行会被自动从输入值中移队。可以使用如：pattern 和 maxlength 样的属性来约束输入的值。 恰当的时候使可以应用 :valid 和 :invalid CSS 伪类。 week：HTML5 用于输入一个由星期-年组成的日期，日期不包括时区。 accept: 如果该元素的 type 属性的值是file,则该属性表明了服务器端可接受的文件类型；否则它将被忽略,该属性的值必须为一个逗号分割的列表,包含了多个唯一的内容类型声明： 以 STOP 字符 (U+002E) 开始的文件扩展名。（例如：”.jpg,.png,.doc”） 一个有效的 MIME 类型，但没有扩展名 audio/* 表示音频文件 video/* 表示视频文件 image/* 表示图片文件 autocomplete: 这个属性表示这个控件的值是否可被浏览器自动填充。如果type属性的值是hidden、checkbox、radio、file，或为按钮类型（button、submit、reset、image），则本属性被忽略。 autofocus: 这个布尔属性允许您指定的表单控件在页面加载时具有焦点（自动获得焦点），除非用户将其覆盖，例如通过键入不同的控件。文档中只有一个表单元素可以具有autofocus属性，它是一个布尔值。 如果type属性设置为隐藏则不能应用（即您不能自动获得焦点的属性设置为隐藏的控件）。 disabled: 这个布尔属性表示此表单控件不可用。 特别是在禁用的控件中， click 事件 将不会被分发 。 并且，禁用的控件的值在提交表单时也不会被提交。如果 type 属性为 hidden，此属性将被忽略。 more button标签HTML button 元素表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方 input和button区别: 是否是空元素, button有子元素, input没有 属性 type: button的类型 submit: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。 reset: 此按钮重置所有组件为初始值。 button: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。 menu: 此按钮打开一个由指定``元素进行定义的弹出菜单。 如果form表单里只有一个button标签, 那么这个button标签会自动升级为提交submit按钮 name: button的名称，与表单数据一起提交。 value: button的初始值。它定义的值与表单数据的提交按钮相关联。当表单中的数据被提交时，这个值便以参数的形式被递送至服务器。 more 转自掘金："},{"title":"curl指令与http请求响应","date":"2019-05-29T16:00:00.000Z","url":"/2019/05/30/curl%E6%8C%87%E4%BB%A4%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/","tags":["http"],"content":"curl简单介绍​ curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在“标准输出”（stdout）上面。 它支持多种协议，下面举例讲解如何作用于网站开发。 ​ 一、查看网页源码直接在curl命令后加上网址，就可以看到网页源码。 ​ 二、显示通信过程-v 参数可以显示一次http通信的整个过程，包括端口连接和http request头信息 ​ 三、发送表单信息发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。 POST方法必须把数据和网址分开，curl就要用到–data参数。 ​ 四、HTTP动词curl默认的HTTP动词是GET，使用“-X”参数可以支持其他动词。 详细请看：阮一峰  ​ HTTP 响应请求示例请求1 注：**-s** 静默模式，不显示进度表或错误信息，使curl静音 请求的内容为 请求2 注：**-H** 自定义头信息传递给服务器 请求的内容为 请求3 请求的内容为 ​ 请求的格式 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远是一个回车（\\n）为了区别开第二与第三 动词有GET POST PUT PATCH DELETE HEAD OPTIONS 等 这里的路径包括“查询参数”，但不包括“锚点” 如果没有写路径，那么路径默认为/ 第二部分中的 Content-Type 标注了第四部分的格式 ​ 用 Chrome 开发者工具查看 HTTP 请求内容 打开 Network 地址栏输入网址 在 Network 点击，查看 request 点击「view source」之后，可以看到请求的前三部分了 如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到 注：若是没有显示「view source」可以是用 curl 命令查看请求 ​ HTTP 响应响应请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了。 ​ 响应示例上部分的前两个请求对应的相应分别为 GET请求和POST请求对应的响应可以一样，也可以不一样 ​ 响应的格式​ 状态码简明小解 1xx 不常用 2xx 表示成功 3xx 表示滚吧 4xx 表示你丫错了 5xx 表示好吧，我错了 状态解释没什么用 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第 2 部分中的 Content-Type 遵循 MIME 规范 ​ 使用Chrome开发者工具查看 HTTP 响应内容​ 打开Network 输入网址 输入网址 查看 Response Headers，点击「view source」 你会看到响应的前两部分 查看 Response 或者 Preview，你会看到响应的第 4 部分 注：若是没有显示「view source」可以是用 curl 命令查看请求 ​ "},{"title":"命令行基本操作以及explainshell的使用","date":"2019-05-25T16:00:00.000Z","url":"/2019/05/26/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8Aexplainshell%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":["linux"],"content":"命令行一些名词 图形界面 命令行：在终端窗口下输入一些命令就可以满足一些操作需求 终端：mac下打开终端（terminal），win下打开gitbash shell：执行当前脚本的一个载体，统称shell。如输入命令ls，即展示当前文件下的所有文件（ls本质上是字符串），通过shell底层地接受字符串的操作输入，在底层做一些文件检索，最终展示出ls发出的请求的文件 bash：本质上是一个软件 安装使用 win安装git，打开gitbash linux：打开终端 mac：打开终端、iterm ​ explainshell使用explainshell顾名思义，就是解释命令行的意思 打开浏览器，输入地址栏输入  在搜索栏中输入你想要解释的命令比如 例：比如我们想要查找 curl 就表示跳转至某个URL -s 在curl这条命令里就表示不要展示进度条 -v 在curl这条命令里就表示显示一次http通信的整个过程，包括端口连接和http request头信息 ​ 基本操作好吧这些基本操作都是我在explain查的然后复制过来的( ﾟ∀。) lslist directory contents–列出目录内容 catconcatenate files and print on the standard output–连接文件并在标准输出中打印 mvmove (rename) files–移动(重命名)文件 touchchange file timestamps–更改文件的时间戳(或者创建一个不存在的文件) 好吧就是这些，具体参数请在网址栏输入  自行查找"},{"title":"从URL输入到页面展现","date":"2019-05-17T16:00:00.000Z","url":"/2019/05/18/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0/","content":"当我们在地址栏输入www.baidu.com 时，都发生了什么呢？ 大概的流程是这样的 在浏览器的地址栏中输入URL DNS域名解析 服务器处理响应 网站处理流程 浏览器渲染页面 ​ 在浏览器的地址栏输入URL何为URL？ URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上的资源，实际上就是网站网址。 URL通常以传输协议、域名、端口、文件路径这几部分组成。 当你输入 www.baidu.com 时并敲回车，浏览器会自动在前面补上该网站相应的协议，此时地址栏的地址是一个完整的URL  ​ DNS域解析每一个服务器都有一个ip地址，但是ip地址过于繁杂难记，一般来说都有一个域名方便记忆，每个域名是唯一的。 当第一步浏览器从URL中解析出服务器对应的域名，以 www.baidu.com 为例，但是浏览器只认得数字，所以这时候就通过DNS域解析来得到该域名所对应的ip地址。 ​ 域名解析的流程： 查找浏览器缓存——我们日常浏览网站时，浏览器会缓存DNS记录一段时间。如果以前我们访问过该网站，那么在浏览器中就会有相应的缓存记录。因此，我们输入网址后，浏览器会首先检查缓存中是否有该域名对应的IP信息。如果有，则直接返回该信息供用户访问网站，如果查询失败，会从系统缓存中进行查找。 查找系统缓存——从hosts文件中查找是否有存储的DNS信息（MAC端，可在“终端”中输入命令cat etc/hosts找到hosts文件位置），如果查询失败，可从路由器缓存中继续查找。 查找路由器缓存——如果之前访问过相应的网站，一般路由器也会缓存信息。如果查询失败，可继续从 ISP DNS 缓存查找。 查找ISP DNS缓存——从网络服务商（例如电信）的DNS缓存信息中查找。 如果经由以上方式都没找到对应IP的话，则向根域名服务器查找域名对应的IP地址，根域名服务器把请求转发到下一级，逐层查找该域名的对应数据，直到获得最终解析结果或失败的相应。 根域名服务器，根服务器主要用来管理互联网的主目录。是互联网域名解析系统（DNS）中最高级别的域名服务器。 ​ 什么是DNS劫持？ DNS劫持（Domain Name System，域名劫持），是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。简单来说，就是你输入的是知乎的网址，但是却跳转到了百度的页面。 ​ 为什么修改DNS为114.114.114.114或8.8.8.8可以解决电脑上不了网的问题？ 当你使用手机端可以正常打开网站，但是在电脑端访问网站失败的话，那么可能是DNS配置出现了问题，或者是在路由器缓存中解析查找错误，无法找到对应的IP地址。那么这时我们可以在电脑端更改DNS进行单独配置即可正常访问（MAC端，打开“网络偏好设置”——“高级”——“DNS”进行修改）。8.8.8.8是谷歌提供的免费DNS服务器的IP地址，114.114.114.114是电信的。 ​ 服务器处理响应浏览器通过IP地址找到对应的服务器，要求建立TCP链接，此时服务器开始处理用户请求。 ​ 服务器是什么？ 服务器是一台安装系统的机器。常见的系统有Linux、Windows Server2012等。系统里安装的处理请求的应用叫Web server。 ​ 服务器如何处理请求？ 由服务器上安装的处理请求的应用（Web Server）来处理。常见的Web服务器有：Apache、Nginx、IIS、Lighttpd。Web服务器接收用户的Requset交给网站代码或反向代理到其他服务器。 ​ TCP是什么？ TCP是互联网中的传输层协议，提供可靠的链接服务，采用三次握手确认一个连接： 浏览器向服务器发送建立连接的请求。 服务器接收到浏览器发送的请求后，想浏览器发送统一连接的信号。 浏览器接受到服务器发出的同意连接的信号后，再次向服务器发出确认连接的信号。 当三次握手返程，TCP客户端和服务端成功的建立连接，就可以开始传输数据了。 ​ 网站处理流程用户输入网址后向服务器发送内容请求，服务器接收到请求后触发Controller（控制器），控制器从Model（模型）和视图（View）中获取各种数据信息进行处理，最后视图（View）将数据渲染为HTML使得页面完整的呈献给用户。 ​ MVC是什么 MVC是一种设计模式，全名是Model View Controller，是模型（Model）- 视图（View）- 控制器（Controller）的缩写。 Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据苦衷存取数据。 View（视图）是应用程序中处理数据显示的部分。通常视图是一句模型数据创建的。而这一部分也是我们前端工作中很重要的一项内容。 Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 ​ 浏览器渲染页面 HTML字符串被浏览器接收后被一句句读取解析。 解析到link标签后重新发送请求获取CSS。 解析到script标签后发送请求获取JS，并执行代码。 解析到img标签后发送请求获取图片资源。 浏览器根据HTML和CSS计算得到渲染书，绘制到屏幕上。 JS会被执行，页面展现。 "},{"title":"浅析URL","date":"2019-05-12T16:00:00.000Z","url":"/2019/05/13/%E6%B5%85%E6%9E%90URL/","tags":["http"],"content":"浅析URL李爵士发明了三样东西 URL、HTTP、HTML，这三样东西组成了万维网今天就主要来了解下URL这就要从ip说起 Internet Protocolprotocol的意思就是协议只要身在互联网中，你至少有一个独特的IPIP主要干了两件事 如何定位一台设备 如何封装数据报文，以跟其他设备交流（因为是浅析URL，所以这个具体内容不关心） 几个特殊的IP127.0.0.1 表示自己localhost 通过hosts指定为自己0.0.0.0不表示任何设备 有了IP，知道了服务器的地址，那么还需要什么？ 端口还需要端口提供网络服务 一台机器可以提供很多服务，每个服务一个号码，这个号码就叫做端口号port 要提供HTTP服务最好使用80端口要提供HTTPS服务最好使用443端口一共有65535个端口（不愁用） 总之端口和IP缺一不可 有人可能会觉得IP地址这么长一串，头大！别慌，我们来了解一下域名 域名域名就是对IP的别称我们在网址框打的baidu.com对应什么IP呢？我们这时就可以使用ping工具[39.156.69.79]就是baidu.com对应的IP地址 有的小伙伴ping baidu.com可能得到的和我不是一个ip地址一个域名可以对应不同IP访问 baidu.com 华南华北的可能就不是一个ip地址，防止人数太多服务器撑不住，这个叫做均衡负载同样一个IP也可以对应不同的域名，这个叫做共享主机，穷开发者会这么做 域名和IP又是怎么对应起来的呢？通过DNS DNSDNS全名为Domain Name System 域名解析系统 当你在网址栏输入baidu.com时你的chrome浏览器会向电信/联通提供的DNS服务器询问baidu.com对应什么IP电信/连通管会回答一个IP（很复杂）然后chrome才会想对应IP的80/443端口发送请求请求内容是查看baidu.com的首页为什么0是80/443端口？服务器默认使用80提供http服务服务器默认使用443提供https服务 如何请求不同的页面使用不同的路径 同一个页面，不同内容使用查询参数 同一个内容，不同位置使用锚点参考书教程 注意锚点不支持中文锚点无法在Network面板看到因为锚点不会传给服务器 URL这时，一个完整的URL就得出了 协议+域名或IP+端口号+路径+查询字符串+锚点举例就算没写也应该知道端口号HTTPS默认端口443"}]